import{_ as a,c as s,o as l,N as e}from"./chunks/framework.cd0483b5.js";const y=JSON.parse('{"title":"浏览器垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"files/docs/Network/02-浏览器垃圾回收机制.md","lastUpdated":1684487890000}'),o={name:"files/docs/Network/02-浏览器垃圾回收机制.md"},n=e(`<h1 id="浏览器垃圾回收" tabindex="-1">浏览器垃圾回收 <a class="header-anchor" href="#浏览器垃圾回收" aria-label="Permalink to &quot;浏览器垃圾回收&quot;">​</a></h1><h2 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h2><p>我们知道，程序运行中会有一些垃圾数据不再使用，需要及时释放出去，如果我们没有及时释放，这就是内存泄露</p><p>JS 中的垃圾数据都是由垃圾回收（<strong>Garbage Collection</strong>，缩写为 <strong>GC</strong>）器自动回收的，不需要手动释放，它是如何做的喃？</p><p>很简单，JS 引擎中有一个后台进程称为垃圾回收器，它监视所有对象，观察对象是否可被访问，然后按照固定的时间间隔周期性的删除掉那些不可访问的对象即可</p><p>现在各大浏览器通常用采用的垃圾回收有两种方法：</p><ul><li>引用计数</li><li>标记清除</li></ul><h2 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h2><p>最早最简单的垃圾回收机制，就是给一个占用物理空间的对象附加一个引用计数器，当有其它对象引用这个对象时，这个对象的引用计数加一，反之解除时就减一，当该对象引用计数为 0 时就会被回收。</p><blockquote><p>该方式很简单，但会引起内存泄漏</p></blockquote><p>现在已经很少使用了，只有低版本的 IE 使用这种方式。</p><h2 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h2><p>V8 中主垃圾回收器就采用标记清除法进行垃圾回收。主要流程如下：</p><ul><li><p>标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。</p></li><li><p>垃圾清理：将所有垃圾数据清理掉</p></li></ul><p>在我们的开发过程中，如果我们想要让垃圾回收器回收某一对象，就将对象的引用直接设置为 <code>null</code></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {} 可访问，a 是其引用</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 引用设置为 null</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// {} 将会被从内存里清理出去</span></span></code></pre></div><p>如果一个对象被多次引用时，例如作为另一对象的键、值或子元素时，将该对象引用设置为 <code>null</code> 时，该对象是不会被回收的，依然存在</p>`,17),t=[n];function p(c,r,i,_,d,h){return l(),s("div",null,t)}const C=a(o,[["render",p]]);export{y as __pageData,C as default};
