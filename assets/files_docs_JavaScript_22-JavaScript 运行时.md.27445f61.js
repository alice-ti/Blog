import{_ as a,o as e,c as l,O as t}from"./chunks/framework.999b5480.js";const m=JSON.parse('{"title":"JavaScript runtime","description":"","frontmatter":{},"headers":[],"relativePath":"files/docs/JavaScript/22-JavaScript 运行时.md","filePath":"files/docs/JavaScript/22-JavaScript 运行时.md","lastUpdated":1687782807000}'),s={name:"files/docs/JavaScript/22-JavaScript 运行时.md"},o=t(`<h1 id="javascript-runtime" tabindex="-1">JavaScript runtime <a class="header-anchor" href="#javascript-runtime" aria-label="Permalink to &quot;JavaScript runtime&quot;">​</a></h1><img src="https://gcdeng.com/assets/images/js-engine-c9d4b21208066e974fa3a538c0dd79c2.jpeg" alt="js-engine.jpeg" style="zoom:150%;"><p>可以把浏览器的 runtime 想成一个机器，这个机器由若干个零件组成。</p><p><img src="https://ithelp.ithome.com.tw/upload/images/20210909/20129476TQdN4y0K6I.png" alt="runtime"></p><h2 id="javascript-引擎" tabindex="-1">JavaScript 引擎 <a class="header-anchor" href="#javascript-引擎" aria-label="Permalink to &quot;JavaScript 引擎&quot;">​</a></h2><p>里面有两个东西：</p><ol><li>Memory Heap</li><li>Calling Stack</li></ol><h3 id="memory-heap-堆" tabindex="-1">Memory Heap（堆） <a class="header-anchor" href="#memory-heap-堆" aria-label="Permalink to &quot;Memory Heap（堆）&quot;">​</a></h3><ol><li>分配空间给「复杂数据类型」使用，分配好之后会得到一个地址（例如 function, object, array）</li><li>释放不再使用的内存空间(Garbage Collection)</li></ol><h3 id="calling-stack-栈" tabindex="-1">Calling Stack（栈） <a class="header-anchor" href="#calling-stack-栈" aria-label="Permalink to &quot;Calling Stack（栈）&quot;">​</a></h3><ol><li>用来保存「基本数据类型」（例如 number, string…）</li><li>JavaScript 执行上下文（Execution Context）（决定什么时候会做什么事情）</li></ol><h3 id="web-apis" tabindex="-1">Web APIs <a class="header-anchor" href="#web-apis" aria-label="Permalink to &quot;Web APIs&quot;">​</a></h3><ol><li>通过浏览器 <code>window</code> 物件可以用浏览器提供的方法</li><li>所以 JavaScript 本身沒有这些方法，只是接到了浏览器的 <em><strong>Web APIs</strong></em> 所以才可以用它们</li></ol><h3 id="callback-queue-task-queue-回调队列也叫消息队列" tabindex="-1">Callback Queue/Task Queue（<strong>回调队列</strong>也叫<strong>消息队列</strong>） <a class="header-anchor" href="#callback-queue-task-queue-回调队列也叫消息队列" aria-label="Permalink to &quot;Callback Queue/Task Queue（**回调队列**也叫**消息队列**）&quot;">​</a></h3><p>这个队列负责保存「已经调用」的 <code>callback function</code>。然后当 <code>Calling Stack</code> 空了的时候，<strong>Event loop</strong> 就会把队列中的 <code>callback function</code> 传给 <code>Calling Stack</code> ，以便执行 <code>callback function</code> 的任务。</p><h3 id="event-loop-事件循环" tabindex="-1">Event Loop（<strong>事件循环</strong>） <a class="header-anchor" href="#event-loop-事件循环" aria-label="Permalink to &quot;Event Loop（**事件循环**）&quot;">​</a></h3><p>Event Loop 最重要的工作，就是控制 <em>Call Stack</em> 和 <em>Callback Queue(Task Queue)</em></p><p><code>Event Loop</code>只有一个任务：检查call stack是否是空的，如果发现是空的，就从消息队列(callback queue)推送(push)一个任务(item)进call stack</p><blockquote><p>要注意 Event loop 一次只会推一个，当 call stack 空了它才会推另一个。</p></blockquote><p><img src="https://cdn.datainfinities.com/images/10-event-loop.png" alt="event-loop"></p><ol><li>Javascript engine 执行 call stack 中的任务。</li><li>当遇到 Web APIs 或是无法处理的任务时候会交给 Javascript runtime 执行，Javascript runtime 处理完成后会将任务交给 callback function，并将 callback function 放进 queue 中，形成 Callback Queue。</li><li>Javascript runtime 等待 call stack 中的任务全部执行结束变成空的，从 callback queue 中拉取第一个任务放进 call stack，回到第一步继续重复循环下去。</li></ol><h3 id="macrotask-queue-宏任务" tabindex="-1">Macrotask Queue（宏任务） <a class="header-anchor" href="#macrotask-queue-宏任务" aria-label="Permalink to &quot;Macrotask Queue（宏任务）&quot;">​</a></h3><p>macrotask 包含：</p><ul><li>从 <code>&lt;script src=&quot;...&quot;&gt;</code> 外部下载的 script</li><li>DOM event handlers，例如 mousemove event 的 callback function handler</li><li>各种 Web APIs，例如 setTimeout 的 callback function</li><li>ajax callback function</li></ul><p>macrotask 在执行时浏览器不会渲染(render)DOM，浏览器会被阻塞住，也就是只执行 macrotask 不会做其他事情，有时我门会看到浏览器跳出页面沒有响应的警告，可能就是因為 macrotask 有复杂运算(CPU-hungry tasks)或是代码逻辑错误导致无限循环发生，使得其他任务无法被处理。</p><img src="https://gcdeng.com/assets/images/Screen_Shot_2021-05-16_at_10.37.11_PM-82dd3d3de0ac10d80cccff54a783ea5e.png" style="zoom:150%;"><h3 id="microtask-queue-微任务" tabindex="-1">Microtask Queue（微任务） <a class="header-anchor" href="#microtask-queue-微任务" aria-label="Permalink to &quot;Microtask Queue（微任务）&quot;">​</a></h3><p>microtask 包含:</p><ul><li>Promise <code>.then/catch/finally</code> 中的 callback function</li><li><code>queueMicrotask(func)</code> 中的 func</li></ul><p>每个 macrotask 执行结束后会先將 microtask queue 中的 task 全部执行完，才会继续执行浏览器渲染跟其他 macrotask。</p><p>将 callback queue 分解成 macrotask 以及 microtask 之后，他门在 Event Loop 中详细的运行流程会是这样：</p><ol><li>从 macrotask queue 中拿出一个 macrotask 丟到 call stack 中执行。</li><li>將 microtask queue 中全部的 task 依照顺序 Dequeue 到 call stack 中执行。</li><li>Browser render DOM。</li><li>如果 macrotask queue 是空的，sleep 直到 macrotask 再次出现。</li><li>回到步驟 1。</li></ol><img src="https://gcdeng.com/assets/images/Screen_Shot_2021-05-17_at_12.55.38_AM-6ebd3c9e3fe41d1f60883fda4dff857a.png" style="zoom:150%;"><h2 id="调用栈-call-stack" tabindex="-1">调用栈 (Call Stack) <a class="header-anchor" href="#调用栈-call-stack" aria-label="Permalink to &quot;调用栈 (Call Stack)&quot;">​</a></h2><p>JavaScript 是一个单线程编程语言，这意味着它只有一个调用栈。因此在同一时间它执行一个任务。</p><p><code>Call Stack</code> 会记录我们目前代码跑到什么位置，如果执行了一个函数，我们会把这个函数放到 (pop in) Stack 的顶端，函数执行结束之后，这个函数就会跳出 (pop out) Stack 中</p><p>调用栈是一种我们程序中的基本记录的数据结构。</p><ul><li>每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。</li><li>正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。</li><li>当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。</li></ul><p><img src="https://gcdeng.com/assets/images/js-call-stack-dc991081d4b66d710932b193427678af.png" alt="js-call-stack.png"></p><h2 id="执行过程" tabindex="-1">执行过程 <a class="header-anchor" href="#执行过程" aria-label="Permalink to &quot;执行过程&quot;">​</a></h2><p>JavaScript 执行过程分为两个阶段:</p><ul><li>编译阶段</li><li>执行阶段</li></ul><h3 id="编译阶段" tabindex="-1">编译阶段 <a class="header-anchor" href="#编译阶段" aria-label="Permalink to &quot;编译阶段&quot;">​</a></h3><p>在编译阶段 JS 引擎主要做了三件事：</p><ul><li>词法分析</li><li>语法分析</li><li>字节码生成</li></ul><h3 id="执行阶段" tabindex="-1">执行阶段 <a class="header-anchor" href="#执行阶段" aria-label="Permalink to &quot;执行阶段&quot;">​</a></h3><p>在执行阶段，会分情况创建各种类型的执行上下文，例如：<strong>全局执行上下文</strong> (只有一个)、<strong>函数执行上下文</strong>。而执行上下文的创建分为两个阶段：</p><ul><li>创建阶段</li><li>执行阶段</li></ul><p>在创建阶段会做如下事情：</p><ul><li>绑定 this</li><li>为函数和变量分配内存空间</li><li>初始化相关变量为 <code>undefined</code></li></ul><p>我们日常提到的 变量提升 和 函数提升 就是在 <strong>创建阶段</strong> 做的，所以下面的写法并不会报错：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(msg)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> msg </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>因为在执行之前的创建阶段，已经分配好了 <code>msg</code> 和 <code>add</code> 的内存空间。</p><hr><p><a href="https://lyn-ho.github.io/posts/b2f2d94f/" target="_blank" rel="noreferrer">JavaScript 工作原理：JS 引擎，runtime 和调用栈的概述</a></p><p><a href="https://ithelp.ithome.com.tw/m/articles/10261593" target="_blank" rel="noreferrer">解釋 Event Loop ( 下 ) --- Task Queue ( Callback Queue )</a></p><p><a href="https://www.datainfinities.com/10/event-loop-and-callback-queue-in-javascript" target="_blank" rel="noreferrer">Event Loop and Callback Queue in JavaScript</a></p><p><a href="https://gcdeng.com/series/Javascript/javascript-deep-dive-into-event-loop" target="_blank" rel="noreferrer">深入了解事件循环(Event Loop，Macrotask和Microtask)</a></p>`,58),c=[o];function n(i,r,p,u,d,h){return e(),l("div",null,c)}const g=a(s,[["render",n]]);export{m as __pageData,g as default};
