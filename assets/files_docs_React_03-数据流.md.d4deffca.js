import{_ as e,c as t,o as s,e as a}from"./app.5c26ba82.js";const u=JSON.parse('{"title":"React 中数据流向","description":"","frontmatter":{},"headers":[{"level":2,"title":"数据流","slug":"数据流","link":"#数据流","children":[{"level":3,"title":"基于 state 的单向数据流","slug":"基于-state-的单向数据流","link":"#基于-state-的单向数据流","children":[]},{"level":3,"title":"props","slug":"props","link":"#props","children":[]}]},{"level":2,"title":"state、props 区别联系","slug":"state、props-区别联系","link":"#state、props-区别联系","children":[]}],"relativePath":"files/docs/React/03-数据流.md","lastUpdated":1680259866000}'),r={name:"files/docs/React/03-数据流.md"},o=a('<h1 id="react-中数据流向" tabindex="-1">React 中数据流向 <a class="header-anchor" href="#react-中数据流向" aria-hidden="true">#</a></h1><h2 id="数据流" tabindex="-1">数据流 <a class="header-anchor" href="#数据流" aria-hidden="true">#</a></h2><blockquote><p>UI = render(state)</p></blockquote><p>React 的核心特征是 <strong>数据驱动视图</strong>。 React 的视图会随着数据的变化而变化，我们说的组件通信其实就是组件之间建立的数据上的连接，这背后是一套环环相扣的 React 数据流解决方案</p><h3 id="基于-state-的单向数据流" tabindex="-1">基于 <strong>state</strong> 的单向数据流 <a class="header-anchor" href="#基于-state-的单向数据流" aria-hidden="true">#</a></h3><p>所谓单向数据流，指的就是当前组件的 <strong>state</strong> 以 <strong>props</strong> 的形式流动时，只能流向组件树中比自己层级更低的组件</p><p>组件并不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，只是使用新值进行重新渲染。</p><h3 id="props" tabindex="-1">props <a class="header-anchor" href="#props" aria-hidden="true">#</a></h3><p>由于 React 是单向数据流，所以 <strong>props</strong> 基本上也就是从父组件向子组件传递的数据。<strong>props</strong> 是组件的只读属性，组件内部不能直接修改 <strong>props</strong>。</p><h2 id="state、props-区别联系" tabindex="-1"><em>state</em>、<em>props</em> 区别联系 <a class="header-anchor" href="#state、props-区别联系" aria-hidden="true">#</a></h2><p><strong>props</strong> 从某种角度来说，也属于 <strong>state</strong> 的一类</p>',11),n=[o];function p(c,d,i,l,h,_){return s(),t("div",null,n)}const f=e(r,[["render",p]]);export{u as __pageData,f as default};
