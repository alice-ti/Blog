import{_ as a,o as s,c as n,O as o}from"./chunks/framework.999b5480.js";const F=JSON.parse('{"title":"事件机制","description":"","frontmatter":{},"headers":[],"relativePath":"files/docs/React/04-事件处理.md","filePath":"files/docs/React/04-事件处理.md","lastUpdated":1694613449000}'),e={name:"files/docs/React/04-事件处理.md"},t=o(`<h1 id="事件机制" tabindex="-1">事件机制 <a class="header-anchor" href="#事件机制" aria-label="Permalink to &quot;事件机制&quot;">​</a></h1><h2 id="原生事件机制" tabindex="-1">原生事件机制 <a class="header-anchor" href="#原生事件机制" aria-label="Permalink to &quot;原生事件机制&quot;">​</a></h2><h3 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h3><p>当某个元素触发某个事件（如 <strong>onclick</strong> ），顶层对象 <strong>document</strong> 就会发出一个事件流，随着 <strong>DOM</strong> 树的节点向目标元素节点流去，<em>直到到达事件真正发生的目标元素</em>。在这个过程中，事件相应的监听函数是不会被触发的。</p><h3 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h3><p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。如果想阻止事件起泡，可以使用 <strong>e.stopPropagation()</strong> 或者 <strong>e.cancelBubble=true(IE)</strong> 来阻止事件的冒泡传播。</p><h3 id="事件委托-事件代理" tabindex="-1">事件委托/事件代理 <a class="header-anchor" href="#事件委托-事件代理" aria-label="Permalink to &quot;事件委托/事件代理&quot;">​</a></h3><p>将一个响应事件委托到另一个元素。当子节点被点击时，<strong>click</strong> 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。其优点在于减少内存消耗和动态绑定事件。</p><h2 id="react-中事件" tabindex="-1">React 中事件 <a class="header-anchor" href="#react-中事件" aria-label="Permalink to &quot;React 中事件&quot;">​</a></h2><p>对于事件处理，<strong>React</strong> 提供了一系列属性。解决方案几乎和使用标准化 <strong>DOM</strong> 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> showAlert </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">alert</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Clicked</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;"> showAlert </span><span style="color:#89DDFF;">} /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">text</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onChange</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">showAlert</span><span style="color:#A6ACCD;">(event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#89DDFF;">} /&gt;</span></span></code></pre></div><h2 id="react-合成事件" tabindex="-1">React 合成事件 <a class="header-anchor" href="#react-合成事件" aria-label="Permalink to &quot;React 合成事件&quot;">​</a></h2><p>抹平不同浏览器API 的差异，更便于跨平台 事件合成可以处理兼容性问题 利用事件委托机制，支持动态绑定，简化了DOM 事件处理逻辑，减少了内存开销</p>`,13),l=[t];function p(r,c,i,D,h,y){return s(),n("div",null,l)}const A=a(e,[["render",p]]);export{F as __pageData,A as default};
