import{_ as a,c as i,o as t,af as e}from"./chunks/framework.BivmJ8bT.js";const c=JSON.parse('{"title":"事件机制","description":"","frontmatter":{},"headers":[],"relativePath":"docs/React/04-事件处理.md","filePath":"docs/React/04-事件处理.md","lastUpdated":1748594539000}'),n={name:"docs/React/04-事件处理.md"};function h(l,s,r,p,k,o){return t(),i("div",null,s[0]||(s[0]=[e(`<h1 id="事件机制" tabindex="-1">事件机制 <a class="header-anchor" href="#事件机制" aria-label="Permalink to &quot;事件机制&quot;">​</a></h1><h2 id="原生事件机制" tabindex="-1">原生事件机制 <a class="header-anchor" href="#原生事件机制" aria-label="Permalink to &quot;原生事件机制&quot;">​</a></h2><h3 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h3><p>当某个元素触发某个事件（如 <strong>onclick</strong> ），顶层对象 <strong>document</strong> 就会发出一个事件流，随着 <strong>DOM</strong> 树的节点向目标元素节点流去，<em>直到到达事件真正发生的目标元素</em>。在这个过程中，事件相应的监听函数是不会被触发的。</p><h3 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h3><p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。如果想阻止事件起泡，可以使用 <strong>e.stopPropagation()</strong> 或者 <strong>e.cancelBubble=true(IE)</strong> 来阻止事件的冒泡传播。</p><h3 id="事件委托-事件代理" tabindex="-1">事件委托/事件代理 <a class="header-anchor" href="#事件委托-事件代理" aria-label="Permalink to &quot;事件委托/事件代理&quot;">​</a></h3><p>将一个响应事件委托到另一个元素。当子节点被点击时，<strong>click</strong> 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。其优点在于减少内存消耗和动态绑定事件。</p><h2 id="react-中事件" tabindex="-1">React 中事件 <a class="header-anchor" href="#react-中事件" aria-label="Permalink to &quot;React 中事件&quot;">​</a></h2><p>对于事件处理，<strong>React</strong> 提供了一系列属性。解决方案几乎和使用标准化 <strong>DOM</strong> 完全一样。也有一些不同点，比如使用驼峰式或传入的是函数，但总体来说，还是十分相似的。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showAlert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Clicked&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ showAlert } /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;text&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showAlert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.target.value) } /&gt;</span></span></code></pre></div><h2 id="react-合成事件" tabindex="-1">React 合成事件 <a class="header-anchor" href="#react-合成事件" aria-label="Permalink to &quot;React 合成事件&quot;">​</a></h2><p>抹平不同浏览器API 的差异，更便于跨平台 事件合成可以处理兼容性问题 利用事件委托机制，支持动态绑定，简化了DOM 事件处理逻辑，减少了内存开销</p>`,13)]))}const g=a(n,[["render",h]]);export{c as __pageData,g as default};
