import{_ as i,c as e,o as s,af as t}from"./chunks/framework.BivmJ8bT.js";const k=JSON.parse('{"title":"月刊少女-2024限定版","description":"","frontmatter":{},"headers":[],"relativePath":"notes/2024月刊少女.md","filePath":"notes/2024月刊少女.md","lastUpdated":1748594539000}'),l={name:"notes/2024月刊少女.md"};function r(o,a,n,h,p,c){return s(),e("div",null,a[0]||(a[0]=[t(`<h1 id="月刊少女-2024限定版" tabindex="-1">月刊少女-2024限定版 <a class="header-anchor" href="#月刊少女-2024限定版" aria-label="Permalink to &quot;月刊少女-2024限定版&quot;">​</a></h1><h2 id="january" tabindex="-1">January <a class="header-anchor" href="#january" aria-label="Permalink to &quot;January&quot;">​</a></h2><h3 id="react-19-即将推出的-4-个全新-hooks" tabindex="-1"><a href="https://mp.weixin.qq.com/s/KFUikcgNvNw15wqM2wPHJw" target="_blank" rel="noreferrer">React 19 即将推出的 4 个全新 Hooks</a> <a class="header-anchor" href="#react-19-即将推出的-4-个全新-hooks" aria-label="Permalink to &quot;[React 19 即将推出的 4 个全新 Hooks](https://mp.weixin.qq.com/s/KFUikcgNvNw15wqM2wPHJw)&quot;">​</a></h3><ul><li><code>use</code></li><li><code>useOptimistic</code></li><li><code>useFormState</code></li><li><code>useFormStatus</code></li></ul><h4 id="useoptimistic" tabindex="-1">useOptimistic <a class="header-anchor" href="#useoptimistic" aria-label="Permalink to &quot;useOptimistic&quot;">​</a></h4><p><code>useOptimistic</code> Hook 允许在进行提交动作的同时，能够乐观地更新用户界面，提升用户体验。</p><p>其语法如下：</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useOptimistic } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AppContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">optimisticState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addOptimistic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useOptimistic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        state,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 更新函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">currentState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">optimisticValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 合并并返回带有乐观值的新状态  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><strong>乐观更新</strong>：一种更新应用程序中数据的策略。这种策略通常会先更改前端页面，然后向服务器发送请求，如果请求成功，则结束操作；如果请求失败，则页面回滚到先前状态。这种做法可以防止新旧数据之间的跳转或闪烁，提供更快的用户体验。</p></blockquote><h4 id="useformstate" tabindex="-1">useFormState <a class="header-anchor" href="#useformstate" aria-label="Permalink to &quot;useFormState&quot;">​</a></h4><p><code>useFormState</code> 是一个可以根据某个表单动作的结果更新 <code>state</code> 的 Hook。</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">formAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useFormState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn, initialState);</span></span></code></pre></div><blockquote><p><strong>注意</strong>：<code>useFormState</code> 需要从 <code>react-dom</code> 中导入，而不是从 <code>react</code> 中导入。</p></blockquote><h4 id="useformstatus" tabindex="-1">useFormStatus <a class="header-anchor" href="#useformstatus" aria-label="Permalink to &quot;useFormStatus&quot;">​</a></h4><p><code>useFormStatus</code> 用于获取上次表单提交的状态信息。</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useFormStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>它不接收任何参数，会返回一个包含以下属性的 <code>status</code> 对象：</p><ul><li><code>pending</code>：布尔值。如果为 <code>true</code>，则表示父级 <code>&lt;form&gt;</code> 正在等待提交；否则为 false。</li><li><code>data</code>：包含父级 <code>&lt;form&gt;</code> 正在提交的数据；如果没有进行提交或没有父级 <code>&lt;form&gt;</code>，它将为 <code>null</code>。</li><li><code>method</code>：字符串，可以是 &#39;get&#39; 或 &#39;post&#39;。表示父级 <code>&lt;form&gt;</code> 使用 GET 或 POST HTTP 方法 进行提交。默认情况下，<code>&lt;form&gt;</code> 将使用 GET 方法，并可以通过 method 属性指定。</li><li><code>action</code>：一个传递给父级 <code>&lt;form&gt;</code> 的 <code>action</code> 属性的函数引用。如果没有父级 <code>&lt;form&gt;</code>，则该属性为 <code>null</code>。如果在 <code>action</code> 属性上提供了 URI 值，或者未指定 <code>action</code> 属性，<code>status.action</code> 将为 <code>null</code>。</li></ul><blockquote><p>它仅在父级表单使用 <code>action</code> 属性时才有效。</p></blockquote><h3 id="opera-公布非-webkit-内核的ios-浏览器" tabindex="-1"><code>Opera</code> 公布非 <code>WebKit</code> 内核的ios 浏览器 <a class="header-anchor" href="#opera-公布非-webkit-内核的ios-浏览器" aria-label="Permalink to &quot;\`Opera\` 公布非 \`WebKit\` 内核的ios 浏览器&quot;">​</a></h3><p>在苹果确认将遵从 DMA 法案要求，允许开发者在欧洲地区的 App Store 提交不基于WebKit 内核的浏览器后，Opera 宣布将为欧洲的 iPhone 与 iPad 用户带来一款基于自研引警的全新 AI浏览器: 【Opera One】。</p><h3 id="文章" tabindex="-1">文章 <a class="header-anchor" href="#文章" aria-label="Permalink to &quot;文章&quot;">​</a></h3><ul><li><a href="https://juejin.cn/post/7272632260179542050" target="_blank" rel="noreferrer">Performance面板分析性能瓶颈全流程</a></li><li><a href="https://sorrycc.com/react-tips/" target="_blank" rel="noreferrer">react tips</a></li><li><a href="https://sorrycc.com/promise-with-resolvers/" target="_blank" rel="noreferrer">使用 Promise.withResolvers 延迟 Promise</a></li><li><a href="https://bjornlu.com/blog/hot-module-replacement-is-easy" target="_blank" rel="noreferrer">Hot Module Replacement is Easy</a><blockquote><p>云谦译：<a href="https://sorrycc.com/hot-module-replacement-is-easy/" target="_blank" rel="noreferrer">Hot Module Replacement 原理</a></p><p>云谦译：<a href="https://sorrycc.com/react-trend-2024/" target="_blank" rel="noreferrer">2024 年 React 趋势</a></p></blockquote></li></ul><h2 id="march" tabindex="-1">March <a class="header-anchor" href="#march" aria-label="Permalink to &quot;March&quot;">​</a></h2><h3 id="htmx" tabindex="-1">HTMX <a class="header-anchor" href="#htmx" aria-label="Permalink to &quot;HTMX&quot;">​</a></h3><p>👍 优点：</p><ul><li>简单直观的基于 HTML 的语法。</li><li>只需几个 HTML 属性就能发送 AJAX 请求和更新 DOM。</li><li>不需要 JavaScript，直接在 HTML 中实现动态交互。</li><li>整合到现有的 HTML 网页中非常简单。</li><li>轻量级库，仅有几 KB。</li></ul><p>👎 缺点：</p><ul><li>需要后端 UI 服务返回原始 HTML，因此更依赖于前端。</li><li>相对较新</li></ul><h3 id="chrome-123" tabindex="-1"><a href="https://developer.chrome.com/blog/chrome-123-beta?hl=zh-cn" target="_blank" rel="noreferrer"><strong>Chrome 123</strong></a> <a class="header-anchor" href="#chrome-123" aria-label="Permalink to &quot;[**Chrome 123**](https://developer.chrome.com/blog/chrome-123-beta?hl=zh-cn)&quot;">​</a></h3><ul><li><p>CSS</p><ul><li>CSS <code>light-dark()</code> 颜色函数</li><li>CSS 画中画显示模式</li><li>块的 <code>align-content</code> CSS 属性</li><li><code>field-sizing</code> CSS 属性</li><li>CSS <code>text-spacing-trim</code> 属性</li></ul></li><li><p>Web API</p><ul><li><p>导入属性 <code>with</code> 语法</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xxx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;mod&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div></li></ul></li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/GanmepfsEwbJyb2RhWhtnQ" target="_blank" rel="noreferrer">快速了解CSS表单尺寸属性field-sizing</a></p></blockquote><h3 id="文章-1" tabindex="-1">文章 <a class="header-anchor" href="#文章-1" aria-label="Permalink to &quot;文章&quot;">​</a></h3><ul><li><a href="https://juejin.cn/post/7341840038964363283" target="_blank" rel="noreferrer">前端接口防止重复请求实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/Wi9M9_afNmzn32lAiZ1TaA" target="_blank" rel="noreferrer">如何做懂业务的前端</a></li></ul><h2 id="april" tabindex="-1">April <a class="header-anchor" href="#april" aria-label="Permalink to &quot;April&quot;">​</a></h2><h3 id="react-19-beta" tabindex="-1"><a href="https://react.dev/blog/2024/04/25/react-19" target="_blank" rel="noreferrer">React 19 Beta</a> <a class="header-anchor" href="#react-19-beta" aria-label="Permalink to &quot;[React 19 Beta](https://react.dev/blog/2024/04/25/react-19)&quot;">​</a></h3><h4 id="action-异步函数" tabindex="-1">Action（异步函数） <a class="header-anchor" href="#action-异步函数" aria-label="Permalink to &quot;Action（异步函数）&quot;">​</a></h4><ul><li>useTransition 可自动处理 pending 状态</li><li>封了 useActionState 处理 Action 的错误、pending 等，</li><li>form 的 action 属性会自动处理提交</li><li>useFormStatus 可读取父 form 的状态</li><li>useOptimistic 用于乐观更新数据</li><li>action 是可组合的。</li></ul><h3 id="use" tabindex="-1">use <a class="header-anchor" href="#use" aria-label="Permalink to &quot;use&quot;">​</a></h3><ul><li>获取获取资源，支持 promise 和 context</li><li>暂不支持渲染中创建的 promise（额。。）</li><li>use 可以有条件的调用，所以读取上下文相比 useContext 会更灵活。</li></ul><h4 id="react-server-组件" tabindex="-1">React Server 组件 <a class="header-anchor" href="#react-server-组件" aria-label="Permalink to &quot;React Server 组件&quot;">​</a></h4><ul><li>之前 canary 的功能全部搬到 19 beta</li><li>明确 Server 组件默认无指令，&quot;use server&quot; 指令就是给 Server Action 用的</li><li>React Server 组件配套工具不遵循 semver，使用时需写死版本。</li></ul><h4 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h4><ul><li>ref 可作为属性，forwardRef 将弃用</li><li>多个水合不匹配的错误合并显示</li><li>Context 可直接作为 Provider，无需 Context.Provider</li><li>refs 支持清理函数，不用传 null</li><li>useDeferredValue 支持初始值</li><li>原生支持 title、link、meta 文档元数据标签，大多场景无需 react-helmet</li><li>样式支持通过 precedence 声明优先级</li><li>支持 async script</li><li>提供 4 个新 api 用于支持预加载浏览器资源</li></ul><p><a href="https://mp.weixin.qq.com/s/lFdrgzWEIHJGV71iMqugUg" target="_blank" rel="noreferrer">React 19 Beta 都更新了啥</a></p><h2 id="oct" tabindex="-1">Oct <a class="header-anchor" href="#oct" aria-label="Permalink to &quot;Oct&quot;">​</a></h2><p><a href="https://www.threads.net/search?q=%E7%A7%91%E6%8A%80%E6%96%B0%E8%81%9E&amp;serp_type=tags&amp;tag_id=18340015582103043" target="_blank" rel="noreferrer">科技新闻</a></p><h3 id="cursor" tabindex="-1">Cursor <a class="header-anchor" href="#cursor" aria-label="Permalink to &quot;Cursor&quot;">​</a></h3><p><a href="https://sorrycc.com/cursor/" target="_blank" rel="noreferrer">云谦-Cursor</a></p><p>TODO</p><p>chain-webpack 文章</p><p>性能分析 文章</p><p>[科技新闻]:</p>`,53)]))}const u=i(l,[["render",r]]);export{k as __pageData,u as default};
