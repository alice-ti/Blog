import{_ as r,o,c as t,O as e}from"./chunks/framework.999b5480.js";const b=JSON.parse('{"title":"浏览器是怎么渲染的?","description":"","frontmatter":{},"headers":[],"relativePath":"files/wrong/浏览器.md","filePath":"files/wrong/浏览器.md","lastUpdated":1694616268000}'),a={name:"files/wrong/浏览器.md"},n=e('<h1 id="浏览器是怎么渲染的" tabindex="-1">浏览器是怎么渲染的? <a class="header-anchor" href="#浏览器是怎么渲染的" aria-label="Permalink to &quot;浏览器是怎么渲染的?&quot;">​</a></h1><p>浏览器工作大致流程</p><ol><li>构建 DOM 树</li><li>预加载</li><li>构建 CSSOM 树</li><li>Rendering Tree</li><li>布局( Layout )</li><li>Paintting</li><li>Compositing</li><li>Interactivity</li></ol><h2 id="构建dom树" tabindex="-1">构建DOM树 <a class="header-anchor" href="#构建dom树" aria-label="Permalink to &quot;构建DOM树&quot;">​</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" target="_blank" rel="noreferrer">关键渲染路径</a></p><p>处理 <strong>HTML</strong> 标记并构造 <strong>DOM 树</strong>，浏览器会遵守一套步骤将 <strong>HTML</strong> 文件转换为 <strong>DOM 树</strong></p><h2 id="预加载" tabindex="-1">预加载 <a class="header-anchor" href="#预加载" aria-label="Permalink to &quot;预加载&quot;">​</a></h2><p>浏览器构建 <strong>DOM</strong> 树时，这个过程占用了主线程。当这种情况发生时，Preload scanner将解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。</p><p>它将在后台检索资源，以便在主 <strong>HTML</strong> 解析器到达请求的资源时，可能资源已经在运行，或者已经被下载。</p><p>当 JavaScript 解析和执行顺序不重要时，可以添加 <strong>async</strong> 属性或 <strong>defer</strong> 属性。</p><h2 id="构建-cssom-树" tabindex="-1">构建 CSSOM 树 <a class="header-anchor" href="#构建-cssom-树" aria-label="Permalink to &quot;构建 CSSOM 树&quot;">​</a></h2><p>DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。</p><p>CSS 对象模型和 <strong>DOM</strong> 是相似的。<strong>DOM</strong> 和 <strong>CSSOM</strong> 是两棵树。它们是独立的数据结构。浏览器将 <strong>CSS</strong> 规则转换为可以理解和使用的样式映射。浏览器遍历 <strong>CSS</strong> 中的每个规则集，根据 <strong>CSS</strong> 选择器创建具有父、子和兄弟关系的节点树。</p><h2 id="style-rendering-tree" tabindex="-1">Style Rendering Tree <a class="header-anchor" href="#style-rendering-tree" aria-label="Permalink to &quot;Style Rendering Tree&quot;">​</a></h2><p>将 DOM 和 CSSOM 组合成一个 <strong>Render</strong> 树，计算样式树或渲染树从 <strong>DOM 树</strong> 的根开始构建，遍历每个可见节点。</p><h2 id="布局-layout" tabindex="-1">布局 Layout <a class="header-anchor" href="#布局-layout" aria-label="Permalink to &quot;布局 Layout&quot;">​</a></h2><p>布局阶段需要完成两个任务：创建布局树和布局计算</p><p>通过遍历 <strong>DOM 树</strong> 创建渲染树 <strong>LayoutTree</strong>，通过计算 <strong>渲染树</strong> 上每个节点的样式，就能得出来每个元素所占空间的大小和位置。当有了所有元素的大小和位置后，就可以在浏览器的页面区域里去绘制元素的边框。</p><blockquote><p><strong>布局(Layout)</strong> 阶段会依次遍历 <strong>DOM树</strong> 的每一个节点，计算每个节点的几何信息。例如节点的宽度</p></blockquote><p>大部分时候，<strong>DOM 树</strong> 和 节点树 并非是一一对应的。例如 <strong>display: none</strong> 的节点没有布局信息，那么也不会创建对应的 <strong>LayoutTree</strong>。</p><h3 id="reflow-回流、重排" tabindex="-1">reflow(回流、重排) <a class="header-anchor" href="#reflow-回流、重排" aria-label="Permalink to &quot;reflow(回流、重排)&quot;">​</a></h3><p>回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</p><blockquote><p>第一次确定节点的大小和位置称为<strong>布局(Layout)</strong>。随后对节点大小和位置的重新计算称为<strong>回流(reflow)</strong>。</p></blockquote><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 <strong>layout</strong></p><p>例如</p><ul><li>页面首次渲染；</li><li>浏览器窗口大小发生变化；</li><li>元素的内容发生变化；</li><li>元素的尺寸或者位置发生变化；</li><li>元素的字体大小发生变化；</li><li>激活CSS伪类；</li><li>查询某些属性或者调用某些方法；</li><li>添加或者删除可见的DOM元素。</li></ul><h3 id="repaint-重绘" tabindex="-1">repaint(重绘) <a class="header-anchor" href="#repaint-重绘" aria-label="Permalink to &quot;repaint(重绘)&quot;">​</a></h3><p>当对 <strong>DOM</strong> 的修改导致了样式的变化、但未影响其几何属性（比如修改颜色、背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（会跳过重排环节），这个过程叫做 <strong>重绘</strong>。简单来说，<strong>重绘</strong> 是由对元素绘制属性的修改引发的</p><p>由于元素的布局信息也属于可见样式，所以 <strong>reflow</strong> 一定会引起 <strong>repaint</strong></p><p>例如</p><ul><li>color、background 相关属性：background-color、background-image 等；</li><li>outline 相关属性：outline-color、outline-width 、text-decoration；</li><li>border-radius、visibility、box-shadow。</li></ul><h2 id="分层-layer" tabindex="-1">分层 Layer <a class="header-anchor" href="#分层-layer" aria-label="Permalink to &quot;分层 Layer&quot;">​</a></h2><p>主线程会使用一套复杂的策略对整个布局树中进行分层</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会对分层结果有或多或少影响，也可以通过 <strong>will-change</strong> 属性更大程度的影响分层结果</p><h2 id="paintting" tabindex="-1">Paintting <a class="header-anchor" href="#paintting" aria-label="Permalink to &quot;Paintting&quot;">​</a></h2><p>将各个节点绘制到屏幕上,绘制可以将布局树中的元素分解为多个层。将内容提升到 <strong>GPU</strong> 上的层（而不是 <strong>CPU</strong> 上的主线程）可以提高绘制和重新绘制性能。</p><h2 id="compositing" tabindex="-1">Compositing <a class="header-anchor" href="#compositing" aria-label="Permalink to &quot;Compositing&quot;">​</a></h2><p>当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。</p><hr><p>参考文章：</p><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">渲染页面：浏览器的工作原理</a></p></li><li><p><a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" target="_blank" rel="noreferrer">How the browser renders a web page?</a></p></li></ol>',41),i=[n];function l(s,g,p,d,h,c){return o(),t("div",null,i)}const m=r(a,[["render",l]]);export{b as __pageData,m as default};
