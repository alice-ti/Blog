import{_ as a,c as r,o,af as t}from"./chunks/framework.BivmJ8bT.js";const b=JSON.parse('{"title":"service-worker","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/44-service-worker.md","filePath":"docs/JavaScript/44-service-worker.md","lastUpdated":1748594539000}'),c={name:"docs/JavaScript/44-service-worker.md"};function i(p,e,l,n,s,h){return o(),r("div",null,e[0]||(e[0]=[t('<h1 id="service-worker" tabindex="-1">service-worker <a class="header-anchor" href="#service-worker" aria-label="Permalink to &quot;service-worker&quot;">​</a></h1><h2 id="workbox" tabindex="-1"><a href="https://developer.chrome.com/docs/workbox?hl=zh-cn" target="_blank" rel="noreferrer">workbox</a> <a class="header-anchor" href="#workbox" aria-label="Permalink to &quot;[workbox](https://developer.chrome.com/docs/workbox?hl=zh-cn)&quot;">​</a></h2><p>谷歌开源库<code>workbox</code>，<strong>workbox</strong> 内部帮你对缓存做了大量的逻辑代码处理，并且也支持非常多种不同的缓存策略，并且也封装好了 <strong>sw.js</strong> 文件的更新策略，另外它的配置也非常简单。有时候站在巨人的肩膀上是更好的一种选择。</p><p><strong>workbox</strong> 目前封装好的4种缓存策略</p><ul><li>Stale-While-Revalidate</li><li>Cache First</li><li>Network First</li><li>Network Only</li><li>Cache Only</li></ul><h3 id="stale-while-revalidate" tabindex="-1">Stale-While-Revalidate <a class="header-anchor" href="#stale-while-revalidate" aria-label="Permalink to &quot;Stale-While-Revalidate&quot;">​</a></h3><p>这一缓存策略和先有的<code>http</code>的同名策略几乎相同，优先选择本地缓存，随后请求并更新缓存，换而言之，要到下一次请求才会正确更新。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94aad0d9958445eb15b3ccc15ed6f02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p><p>这个缓存策略是首先通过service worker匹配缓存，并且每次仍然还是会fetch一次接口，并将请求的结果更新缓存。如果匹配不到缓存的情况下会直接返回fecth到的数据。</p><h3 id="cache-first" tabindex="-1">CACHE FIRST <a class="header-anchor" href="#cache-first" aria-label="Permalink to &quot;CACHE FIRST&quot;">​</a></h3><p>缓存优先，顾名思义，优先访问缓存，如果在缓存不可用的情况下在使用网络进行请求</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26bc3f9657f049ebb5d9fe7966c6d814~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p><p>可以从代码发现每次都会先匹配缓存，缓存匹配不到才会重新fetch并缓存，所以这种方式对于数据更新频繁的情况并不适用。他比较适用于一些静态资源的缓存。</p><h3 id="network-first" tabindex="-1">NETWORK FIRST <a class="header-anchor" href="#network-first" aria-label="Permalink to &quot;NETWORK FIRST&quot;">​</a></h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a635b5ccf4642eaab5d51bf518fa66e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="image.png"></p><p>network-first 是一个比较复杂的策略，它接受<code>networkTimeoutSeconds</code>参数，如果没有传这个参数，请求将会发出，成功的话就返回结果添加到缓存中，如果失败则返回立即缓存。</p><p>这种网络回退到缓存的方式虽然利于那些频繁更新的资源，但是在网络情况比较差的情况（无网会直接返回缓存）下，等待会比较久，这时<code>networkTimeoutSeconds</code>就提供了作用。如果设置了，会生成一个setTimeout后被resolve的缓存调用，再把它和请求放倒一个Promise.race中，那么请求超时后就会返回缓存。</p><h3 id="network-only" tabindex="-1">NETWORK Only <a class="header-anchor" href="#network-only" aria-label="Permalink to &quot;NETWORK Only&quot;">​</a></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539e5818bcae4d65a874d4c52785599a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="NETWORK FIRST.png"></p><h3 id="cache-only" tabindex="-1">Cache Only <a class="header-anchor" href="#cache-only" aria-label="Permalink to &quot;Cache Only&quot;">​</a></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6862b59d8b42018360805cde52b0f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="Cache FIRST.png"></p><blockquote><p><strong>NETWORK Only</strong> 是只用fetch接口数据，<strong>Cache Only</strong> 是只用缓存，两种一般都不适用。</p></blockquote><hr><p><a href="https://juejin.cn/post/7039258299086143524" target="_blank" rel="noreferrer">vite pwa项目使用</a></p>',24)]))}const f=a(c,[["render",i]]);export{b as __pageData,f as default};
