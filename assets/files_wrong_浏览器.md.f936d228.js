import{_ as e,c as r,o as i,e as a}from"./app.800471f8.js";const m=JSON.parse('{"title":"浏览器是怎么渲染的?","description":"","frontmatter":{},"headers":[{"level":2,"title":"构建DOM树","slug":"构建dom树","link":"#构建dom树","children":[]},{"level":2,"title":"预加载","slug":"预加载","link":"#预加载","children":[]},{"level":2,"title":"构建 CSSOM 树","slug":"构建-cssom-树","link":"#构建-cssom-树","children":[]},{"level":2,"title":"Style Rendering Tree","slug":"style-rendering-tree","link":"#style-rendering-tree","children":[]},{"level":2,"title":"Layout","slug":"layout","link":"#layout","children":[]},{"level":2,"title":"Paintting","slug":"paintting","link":"#paintting","children":[]},{"level":2,"title":"Compositing","slug":"compositing","link":"#compositing","children":[]}],"relativePath":"files/wrong/浏览器.md","lastUpdated":1676870424000}'),t={name:"files/wrong/浏览器.md"},n=a('<h1 id="浏览器是怎么渲染的" tabindex="-1">浏览器是怎么渲染的? <a class="header-anchor" href="#浏览器是怎么渲染的" aria-hidden="true">#</a></h1><p>浏览器工作大致流程</p><ol><li>构建DOM树</li><li>预加载</li><li>构建 CSSOM 树</li><li>Rendering Tree</li><li>Layout</li><li>Paintting</li><li>Compositing</li><li>Interactivity</li></ol><h2 id="构建dom树" tabindex="-1">构建DOM树 <a class="header-anchor" href="#构建dom树" aria-hidden="true">#</a></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" target="_blank" rel="noreferrer">关键渲染路径</a></p><p>处理 HTML 标记并构造 DOM 树，浏览器会遵守一套步骤将HTML 文件转换为 DOM 树</p><h2 id="预加载" tabindex="-1">预加载 <a class="header-anchor" href="#预加载" aria-hidden="true">#</a></h2><p>浏览器构建 DOM 树时，这个过程占用了主线程。当这种情况发生时，Preload scanner将解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。</p><p>它将在后台检索资源，以便在主 HTML 解析器到达请求的资源时，可能资源已经在运行，或者已经被下载。</p><p>当 JavaScript 解析和执行顺序不重要时，可以添加 async 属性或 defer 属性。</p><h2 id="构建-cssom-树" tabindex="-1">构建 CSSOM 树 <a class="header-anchor" href="#构建-cssom-树" aria-hidden="true">#</a></h2><p>DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。</p><p>CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM 是两棵树。它们是独立的数据结构。浏览器将 CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。</p><h2 id="style-rendering-tree" tabindex="-1">Style Rendering Tree <a class="header-anchor" href="#style-rendering-tree" aria-hidden="true">#</a></h2><p>将 DOM 和 CSSOM 组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。</p><h2 id="layout" tabindex="-1">Layout <a class="header-anchor" href="#layout" aria-hidden="true">#</a></h2><p>在渲染树上运行布局以计算每个节点的几何体。 第一个浏览器创建每个单独的渲染树节点的布局。布局由每个节点的大小（以像素为单位）以及它将在屏幕上打印的位置（位置）组成。这个过程称为布局，因为浏览器正在计算每个节点的布局信息。</p><p>此过程也称为重排或浏览器重排，它也可能在您滚动、调整窗口大小或操作<strong>DOM</strong>元素时发生。</p><p>第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。</p><h2 id="paintting" tabindex="-1">Paintting <a class="header-anchor" href="#paintting" aria-hidden="true">#</a></h2><p>将各个节点绘制到屏幕上,绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。</p><h2 id="compositing" tabindex="-1">Compositing <a class="header-anchor" href="#compositing" aria-hidden="true">#</a></h2><p>当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。</p><hr><p>参考文章：</p><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">渲染页面：浏览器的工作原理</a></p></li><li><p><a href="https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969" target="_blank" rel="noreferrer">How the browser renders a web page?</a></p></li></ol>',26),l=[n];function o(d,s,h,p,c,g){return i(),r("div",null,l)}const S=e(t,[["render",o]]);export{m as __pageData,S as default};
