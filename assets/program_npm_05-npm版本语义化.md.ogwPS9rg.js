import{_ as o,c as d,o as c,af as l}from"./chunks/framework.BivmJ8bT.js";const _=JSON.parse('{"title":"npm 版本语义化","description":"","frontmatter":{},"headers":[],"relativePath":"program/npm/05-npm版本语义化.md","filePath":"program/npm/05-npm版本语义化.md","lastUpdated":1748592476000}'),a={name:"program/npm/05-npm版本语义化.md"};function t(i,e,p,n,r,m){return c(),d("div",null,e[0]||(e[0]=[l('<h1 id="npm-版本语义化" tabindex="-1">npm 版本语义化 <a class="header-anchor" href="#npm-版本语义化" aria-label="Permalink to &quot;npm 版本语义化&quot;">​</a></h1><h2 id="语义版本控制作为版本编号" tabindex="-1">语义版本控制作为版本编号 <a class="header-anchor" href="#语义版本控制作为版本编号" aria-label="Permalink to &quot;语义版本控制作为版本编号&quot;">​</a></h2><p>如果 Node.js 软件包中有一件很棒的事情，那就是它们都同意使用。</p><p>语义版本控制的概念很简单：所有的版本都有 3 个数字：<code>x.y.z</code>。</p><ul><li>第一个数字是主版本。</li><li>第二个数字是次版本。</li><li>第三个数字是补丁版本。</li></ul><p>当发布新的版本时，不仅仅是随心所欲地增加数字，还要遵循以下规则：</p><ul><li>当进行不兼容的 API 更改时，则升级主版本。</li><li>当以向后兼容的方式添加功能时，则升级次版本。</li><li>当进行向后兼容的缺陷修复时，则升级补丁版本。</li></ul><p>该约定在所有编程语言中均被采用，每个 <code>npm</code> 软件包都必须遵守该约定，这一点非常重要，因为整个系统都依赖于此。</p><h2 id="为什么这么重要" tabindex="-1">为什么这么重要？ <a class="header-anchor" href="#为什么这么重要" aria-label="Permalink to &quot;为什么这么重要？&quot;">​</a></h2><p>因为 <code>npm</code> 设置了一些规则，可用于在 <code>package.json</code> 文件中选择要将软件包更新到的版本（当运行 <code>npm update</code> 时）。</p><p>规则使用了这些符号：</p><p><code>^</code>、 <code>~</code>、 <code>&gt;</code>、 <code>&gt;=</code>、 <code>&lt;</code>、 <code>&lt;=</code>、 <code>=</code>、 <code>-</code>、 <code>||</code></p><p>这些规则的详情如下：</p><ul><li><code>^</code>: 比如 <code>^1.2.5</code>，代表版本范围 <code>1.*.*</code>。 如果写入的是 <code>^0.13.0</code>，则当运行 <code>npm update</code> 时，可以更新到 <code>0.13.1</code>、<code>0.13.2</code> 等，但不能更新到 <code>0.14.0</code> 或更高版本。</li><li><code>~</code>: 表示 <strong>修订号</strong> 的更新，比如 <code>~1.2.3</code> 代表版本范围 <code>1.2.*</code>。如果写入的是 <code>〜0.13.0</code>，则当运行 <code>npm update</code> 时，会更新到补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li><li><code>&gt;</code>: 接受高于指定版本的任何版本。</li><li><code>&gt;=</code>: 接受等于或高于指定版本的任何版本。</li><li><code>&lt;=</code>: 接受等于或低于指定版本的任何版本。</li><li><code>&lt;</code>: 接受低于指定版本的任何版本。</li><li><code>=</code>: 接受确切的版本。</li><li><code>-</code>: 接受一定范围的版本。例如：<code>2.1.0 - 2.6.2</code>。</li><li><code>||</code>: 组合集合。例如 <code>&lt; 2.1 || &gt; 2.6</code>。</li></ul><p>可以合并其中的一些符号，例如 <code>1.0.0 || &gt;=1.1.0 &lt;1.2.0</code>，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。</p><p>还有其他的规则：</p><ul><li>无符号: 仅接受指定的特定版本（例如 <code>1.2.1</code>）。</li><li><code>latest</code>: 使用可用的最新版本。</li></ul><hr><p><a href="https://dev.nodejs.cn/learn/semantic-versioning-using-npm/" target="_blank" rel="noreferrer">使用 npm 的语义版本控制</a></p>',19)]))}const u=o(a,[["render",t]]);export{_ as __pageData,u as default};
